cmake_minimum_required(VERSION 2.8)

set(PROJECT_NAME YourProjectName)
project(${PROJECT_NAME})

set (${PROJECT_NAME}_MAJOR_VERSION 0)
set (${PROJECT_NAME}_MINOR_VERSION 1)
set (${PROJECT_NAME}_PATCH_VERSION 0)
set(${PROJECT_NAME}_VERSION
    ${${PROJECT_NAME}_MAJOR_VERSION}.${${PROJECT_NAME}_MINOR_VERSION}.${${PROJECT_NAME}_PATCH_VERSION})
# This is used when configuring files
# (this way we have a variable which is not dependent on the project name)
set(PROJECT_VERSION ${${PROJECT_NAME}_VERSION})

option(${PROJECT_NAME}_ENABLE_TESTS "Enable tests" ON)
if(${PROJECT_NAME}_ENABLE_TESTS)
    enable_testing()
endif()

# This file contains the definition of special functions
include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/IncludeFunctions.cmake)

#================================
# Third Party Libraries
#================================
# find_third_party_library looks for a library in TPL_${PACKAGE_NAME}_DIR
# or in the default system paths and appends its include dirs, library dirs
# and library names to the following variables. Some packages don't
# use any variables, but rather provide a USE_FILE that sets up CMake
# to link and include the proper files and directories
set(${PROJECT_NAME}_TPL_INCLUDE_DIRS "" CACHE INTERNAL "")
set(${PROJECT_NAME}_TPL_LIBRARY_DIRS "" CACHE INTERNAL "")
set(${PROJECT_NAME}_TPL_LIBRARIES "" CACHE INTERNAL "")
set(${PROJECT_NAME}_TPL_PACKAGES_PROVIDING_USE_FILES "" CACHE INTERNAL "")

find_third_party_library(Boost COMPONENTS thread)
find_third_party_library(BLAS)
find_third_party_library(CGAL)
find_third_party_library(CHOLMOD)
find_third_party_library(EDFM)
find_third_party_library(EIGEN3)
find_third_party_library(HDF5)
find_third_party_library(Qhull)
find_third_party_library(Trilinos)
find_third_party_library(UMFPACK)
find_third_party_library(VTK)
find_third_party_library(ZLIB)

message(STATUS "${PROJECT_NAME}_TPL_INCLUDE_DIRS = ${${PROJECT_NAME}_TPL_INCLUDE_DIRS}")
message(STATUS "${PROJECT_NAME}_TPL_LIBRARY_DIRS = ${${PROJECT_NAME}_TPL_LIBRARY_DIRS}")
message(STATUS "${PROJECT_NAME}_TPL_LIBRARIES = ${${PROJECT_NAME}_TPL_LIBRARIES}")
message(STATUS "${PROJECT_NAME}_TPL_PACKAGES_PROVIDING_USE_FILES = ${${PROJECT_NAME}_TPL_PACKAGES_PROVIDING_USE_FILES}")

include_directories(${${PROJECT_NAME}_TPL_INCLUDE_DIRS})

link_directories(${${PROJECT_NAME}_TPL_LIBRARY_DIRS})

set(LIBRARIES
    ${${PROJECT_NAME}_TPL_LIBRARIES}
    CACHE INTERNAL "")
message(STATUS "LIBRARIES = ${LIBRARIES}")

#================================
# Flags
#================================
SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -O2")

# Set specific flags for the three different build types (Release, debug and Profile)
# -Wno-unused-local-typedefs suppresses a lot of warnings generated by the debug version of boost
set(CMAKE_CXX_FLAGS_RELEASE "-DNDEBUG")
set(CMAKE_CXX_FLAGS_DEBUG "-D_GLIBCXX_DEBUG -DDEBUG -g -O0")
set(CMAKE_CXX_FLAGS_PROFILE "-pg")
set(CMAKE_CXX_FLAGS_CODECOVERAGE "-g -O0 --coverage")

if("${CMAKE_BUILD_TYPE}" STREQUAL "")
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build, options are: None(CMAKE_CXX_FLAGS or CMAKE_C_FLAGS used) Debug Release Profile CodeCoverage." FORCE)
endif()

IF(CMAKE_BUILD_TYPE STREQUAL "Release")
    message(STATUS "Compiling with flags:\n  ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_RELEASE}")
ELSEIF(CMAKE_BUILD_TYPE STREQUAL "Debug")
    message(STATUS "Compiling with flags:\n  ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_DEBUG}")
ELSEIF(CMAKE_BUILD_TYPE STREQUAL "Profile")
    message(STATUS "Compiling with flags:\n  ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_PROFILE}")
ELSEIF(CMAKE_BUILD_TYPE STREQUAL "CodeCoverage")
    include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/CodeCoverage.cmake)
    message(STATUS "Compiling with flags:\n  ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_CODECOVERAGE}")
    setup_target_for_coverage(${PROJECT_NAME}_coverage ${CMAKE_CTEST_COMMAND} coverage)
ENDIF()

#================================
# Installation directories
#================================
# Offer the user the choice of overriding the installation directories
set(INSTALL_LIB_DIR lib CACHE PATH "Installation directory for libraries")
set(INSTALL_BIN_DIR bin CACHE PATH "Installation directory for executables")
set(INSTALL_INCLUDE_DIR include CACHE PATH
  "Installation directory for header files")

if(WIN32 AND NOT CYGWIN)
  set(DEF_INSTALL_CMAKE_DIR CMake)
else()
  set(DEF_INSTALL_CMAKE_DIR lib/cmake/${PROJECT_NAME})
endif()
set(INSTALL_CMAKE_DIR ${DEF_INSTALL_CMAKE_DIR} CACHE PATH
  "Installation directory for CMake files")

mark_as_advanced(INSTALL_LIB_DIR INSTALL_BIN_DIR INSTALL_INCLUDE_DIR INSTALL_CMAKE_DIR)

#================================
# Subdirectories
#================================
# Directories in which to look for header files
include_directories(".")
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src)

add_subdirectory(src)

#================================
# Doxygen
#================================

# We add a target named "doc" that generates documentation
# with doxygen
find_package(Doxygen)
find_package(LATEX)
if(DOXYGEN_FOUND)
    set(GENERATE_LATEX_DOC "NO")
    # disabled because bad doxygen documentation is generated by some classes
    # that abuse Qt-style comments (/*! description */) without properly
    # generating a brief description in the first line
#    IF(PDFLATEX_COMPILER)
#        set(GENERATE_LATEX_DOC "YES")
#    ENDIF()
    # generate Doxyfile
    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.cmake
        ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile @ONLY)

    # add doc target
    add_custom_target(doc
        ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT "Generating API documentation with Doxygen" VERBATIM
        )
    install(
        DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc/html
        DESTINATION share/doc/${PROJECT_NAME}
        COMPONENT doc
        OPTIONAL
        )

    # add pdf-doc target
    # (disabled because bad doxygen documentation is generated by some classes
    # that abuse Qt-style comments (/*! description */) without properly
    # generating a brief description in the first line )
#    IF(PDFLATEX_COMPILER)
#        add_custom_target(pdf-doc
#            ${CMAKE_BUILD_TOOL}
#            DEPENDS doc
#            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc/latex
#            COMMENT "Generating pdf API documentation with latex" VERBATIM
#            )
#        install(
#            FILES ${CMAKE_CURRENT_BINARY_DIR}/doc/latex/refman.pdf
#            DESTINATION share/doc/${PROJECT_NAME}
#            COMPONENT pdf-doc
#            OPTIONAL
#            )
#    ENDIF()


endif(DOXYGEN_FOUND)

#================================
# ${PROJECT_NAME}Config.cmake
#================================

# This file configures and prepares for installation
# ${PROJECT_NAME}Config.cmake and ${PROJECT_NAME}ConfigVersion.cmake
include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/InstallCMakeConfigFiles.cmake)
